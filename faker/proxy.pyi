import datetime

from collections import OrderedDict
from decimal import Decimal
from json.encoder import JSONEncoder
from typing import (
    Any,
    Callable,
    Collection,
    Dict,
    Iterable,
    Iterator,
    List,
    Literal,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
)
from uuid import UUID

from faker.generator import Generator
from faker.providers import T
from faker.providers.credit_card import CardType
from faker.providers.python import TEnum

class Faker:
    def address(self) -> str: ...
    def administrative_unit(self) -> str: ...
    def bothify(self, text: str = ..., letters: str = ...) -> str: ...
    def building_number(self) -> str: ...
    def city(self) -> str: ...
    def city_prefix(self) -> str: ...
    def city_suffix(self) -> str: ...
    def country(self) -> str: ...
    def country_code(self, representation: str = ...) -> str: ...
    def current_country(self) -> str: ...
    def current_country_code(self) -> str: ...
    def hexify(self, text: str = ..., upper: bool = ...) -> str: ...
    def language_code(self) -> str: ...
    def lexify(self, text: str = ..., letters: str = ...) -> str: ...
    def locale(self) -> str: ...
    def military_apo(self) -> str: ...
    def military_dpo(self) -> str: ...
    def military_ship(self) -> str: ...
    def military_state(self) -> str: ...
    def numerify(self, text: str = ...) -> str: ...
    def postalcode(self) -> str: ...
    def postalcode_in_state(self, state_abbr: Optional[str] = ...) -> str: ...
    def postalcode_plus4(self) -> str: ...
    def postcode(self) -> str: ...
    def postcode_in_state(self, state_abbr: Optional[str] = ...) -> str: ...
    def random_choices(
        self, elements: Union[Collection[str], Collection[T], OrderedDict[T, float]] = ..., length: Optional[int] = ...
    ) -> Sequence[T]: ...
    def random_digit(self) -> int: ...
    def random_digit_above_two(self) -> int: ...
    def random_digit_not_null(self) -> int: ...
    def random_digit_not_null_or_empty(self) -> Union[int, str]: ...
    def random_digit_or_empty(self) -> Union[int, str]: ...
    def random_element(self, elements: Union[Collection[str], Collection[T], OrderedDict[T, float]] = ...) -> T: ...
    def random_elements(
        self,
        elements: Union[Collection[str], Collection[T], OrderedDict[T, float]] = ...,
        length: Optional[int] = ...,
        unique: bool = ...,
        use_weighting: Optional[bool] = ...,
    ) -> Sequence[T]: ...
    def random_int(self, min: int = ..., max: int = ..., step: int = ...) -> int: ...
    def random_letter(self) -> str: ...
    def random_letters(self, length: int = ...) -> Sequence[str]: ...
    def random_lowercase_letter(self) -> str: ...
    def random_number(self, digits: Optional[int] = ..., fix_len: bool = ...) -> int: ...
    def random_sample(
        self, elements: Union[Collection[str], Collection[T], OrderedDict[T, float]] = ..., length: Optional[int] = ...
    ) -> Sequence[T]: ...
    def random_uppercase_letter(self) -> str: ...
    def randomize_nb_elements(
        self, number: int = ..., le: bool = ..., ge: bool = ..., min: Optional[int] = ..., max: Optional[int] = ...
    ) -> int: ...
    def secondary_address(self) -> str: ...
    def state(self) -> str: ...
    def state_abbr(self, include_territories: bool = ..., include_freely_associated_states: bool = ...) -> str: ...
    def street_address(self) -> str: ...
    def street_name(self) -> str: ...
    def street_suffix(self) -> str: ...
    def zipcode(self) -> str: ...
    def zipcode_in_state(self, state_abbr: Optional[str] = ...) -> str: ...
    def zipcode_plus4(self) -> str: ...
    def license_plate(self) -> str: ...
    def vin(self) -> str: ...
    def aba(self) -> str: ...
    def bank_country(self) -> str: ...
    def bban(self) -> str: ...
    def iban(self) -> str: ...
    def swift(self, length: Optional[int] = ..., primary: bool = ..., use_dataset: bool = ...) -> str: ...
    def swift11(self, primary: bool = ..., use_dataset: bool = ...) -> str: ...
    def swift8(self, use_dataset: bool = ...) -> str: ...
    def ean(
        self, length: int = ..., prefixes: Tuple[Union[int, str, Tuple[Union[int, str], ...]], ...] = ...
    ) -> str: ...
    def ean13(
        self,
        prefixes: Tuple[Union[int, str, Tuple[Union[int, str], ...]], ...] = ...,
        leading_zero: Optional[bool] = ...,
    ) -> str: ...
    def ean8(self, prefixes: Tuple[Union[int, str, Tuple[Union[int, str], ...]], ...] = ...) -> str: ...
    def localized_ean(self, length: int = ...) -> str: ...
    def localized_ean13(self) -> str: ...
    def localized_ean8(self) -> str: ...
    def upc_a(
        self, upc_ae_mode: bool = ..., base: Optional[str] = ..., number_system_digit: Optional[int] = ...
    ) -> str: ...
    def upc_e(
        self, base: Optional[str] = ..., number_system_digit: Optional[int] = ..., safe_mode: bool = ...
    ) -> str: ...
    def color(
        self,
        hue: Union[str, float, int, Sequence[int], None] = ...,
        luminosity: Optional[str] = ...,
        color_format: str = ...,
    ) -> str: ...
    def color_hsl(
        self, hue: Union[str, float, int, Sequence[int], None] = ..., luminosity: Optional[str] = ...
    ) -> Tuple[int, int, int]: ...
    def color_hsv(
        self, hue: Union[str, float, int, Sequence[int], None] = ..., luminosity: Optional[str] = ...
    ) -> Tuple[int, int, int]: ...
    def color_name(self) -> str: ...
    def color_rgb(
        self, hue: Union[str, float, int, Sequence[int], None] = ..., luminosity: Optional[str] = ...
    ) -> Tuple[int, int, int]: ...
    def color_rgb_float(
        self, hue: Union[str, float, int, Sequence[int], None] = ..., luminosity: Optional[str] = ...
    ) -> Tuple[float, float, float]: ...
    def hex_color(self) -> str: ...
    def rgb_color(self) -> str: ...
    def rgb_css_color(self) -> str: ...
    def safe_color_name(self) -> str: ...
    def safe_hex_color(self) -> str: ...
    def bs(self) -> str: ...
    def catch_phrase(self) -> str: ...
    def company(self) -> str: ...
    def company_suffix(self) -> str: ...
    def credit_card_expire(
        self,
        start: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        end: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        date_format: str = ...,
    ) -> str: ...
    def credit_card_full(self, card_type: Optional[CardType] = ...) -> str: ...
    def credit_card_number(self, card_type: Optional[CardType] = ...) -> str: ...
    def credit_card_provider(self, card_type: Optional[CardType] = ...) -> str: ...
    def credit_card_security_code(self, card_type: Optional[CardType] = ...) -> str: ...
    def cryptocurrency(self) -> Tuple[str, str]: ...
    def cryptocurrency_code(self) -> str: ...
    def cryptocurrency_name(self) -> str: ...
    def currency(self) -> Tuple[str, str]: ...
    def currency_code(self) -> str: ...
    def currency_name(self) -> str: ...
    def currency_symbol(self, code: Optional[str] = ...) -> str: ...
    def pricetag(self) -> str: ...
    def am_pm(self) -> str: ...
    def century(self) -> str: ...
    def date(
        self,
        pattern: str = ...,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> str: ...
    def date_between(
        self,
        start_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        end_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
    ) -> datetime.date: ...
    def date_between_dates(
        self,
        date_start: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        date_end: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> datetime.date: ...
    def date_object(self, end_datetime: Optional[datetime.datetime] = ...) -> datetime.date: ...
    def date_of_birth(
        self, tzinfo: Optional[datetime.tzinfo] = ..., minimum_age: int = ..., maximum_age: int = ...
    ) -> datetime.date: ...
    def date_this_century(self, before_today: bool = ..., after_today: bool = ...) -> datetime.date: ...
    def date_this_decade(self, before_today: bool = ..., after_today: bool = ...) -> datetime.date: ...
    def date_this_month(self, before_today: bool = ..., after_today: bool = ...) -> datetime.date: ...
    def date_this_year(self, before_today: bool = ..., after_today: bool = ...) -> datetime.date: ...
    def date_time(
        self,
        tzinfo: Optional[datetime.tzinfo] = ...,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> datetime.datetime: ...
    def date_time_ad(
        self,
        tzinfo: Optional[datetime.tzinfo] = ...,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        start_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> datetime.datetime: ...
    def date_time_between(
        self,
        start_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        end_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.datetime: ...
    def date_time_between_dates(
        self,
        datetime_start: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        datetime_end: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.datetime: ...
    def date_time_this_century(
        self, before_now: bool = ..., after_now: bool = ..., tzinfo: Optional[datetime.tzinfo] = ...
    ) -> datetime.datetime: ...
    def date_time_this_decade(
        self, before_now: bool = ..., after_now: bool = ..., tzinfo: Optional[datetime.tzinfo] = ...
    ) -> datetime.datetime: ...
    def date_time_this_month(
        self, before_now: bool = ..., after_now: bool = ..., tzinfo: Optional[datetime.tzinfo] = ...
    ) -> datetime.datetime: ...
    def date_time_this_year(
        self, before_now: bool = ..., after_now: bool = ..., tzinfo: Optional[datetime.tzinfo] = ...
    ) -> datetime.datetime: ...
    def day_of_month(self) -> str: ...
    def day_of_week(self) -> str: ...
    def future_date(
        self,
        end_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.date: ...
    def future_datetime(
        self,
        end_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.datetime: ...
    def iso8601(
        self,
        tzinfo: Optional[datetime.tzinfo] = ...,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        sep: str = ...,
        timespec: str = ...,
    ) -> str: ...
    def month(self) -> str: ...
    def month_name(self) -> str: ...
    def past_date(
        self,
        start_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.date: ...
    def past_datetime(
        self,
        start_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> datetime.datetime: ...
    def pytimezone(self, *args: Any, **kwargs: Any) -> Optional[datetime.tzinfo]: ...
    def time(
        self,
        pattern: str = ...,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> str: ...
    def time_delta(
        self, end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...
    ) -> datetime.timedelta: ...
    def time_object(
        self, end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...
    ) -> datetime.time: ...
    def time_series(
        self,
        start_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        end_date: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int] = ...,
        precision: Optional[float] = ...,
        distrib: Optional[Callable[[datetime.datetime], float]] = ...,
        tzinfo: Optional[datetime.tzinfo] = ...,
    ) -> Iterator[Tuple[datetime.datetime, Any]]: ...
    def timezone(self) -> str: ...
    def unix_time(
        self,
        end_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
        start_datetime: Union[datetime.date, datetime.datetime, datetime.timedelta, str, int, None] = ...,
    ) -> float: ...
    def year(self) -> str: ...
    def emoji(self) -> str: ...
    def file_extension(self, category: Optional[str] = ...) -> str: ...
    def file_name(self, category: Optional[str] = ..., extension: Optional[str] = ...) -> str: ...
    def file_path(
        self,
        depth: int = ...,
        category: Optional[str] = ...,
        extension: Union[str, Sequence[str], None] = ...,
        absolute: Optional[bool] = ...,
        file_system_rule: Literal["linux", "windows"] = ...,
    ) -> str: ...
    def mime_type(self, category: Optional[str] = ...) -> str: ...
    def unix_device(self, prefix: Optional[str] = ...) -> str: ...
    def unix_partition(self, prefix: Optional[str] = ...) -> str: ...
    def coordinate(self, center: Optional[float] = ..., radius: Union[float, int] = ...) -> Decimal: ...
    def latitude(self) -> Decimal: ...
    def latlng(self) -> Tuple[Decimal, Decimal]: ...
    def local_latlng(self, country_code: str = ..., coords_only: bool = ...) -> Optional[Tuple[str, ...]]: ...
    def location_on_land(self, coords_only: bool = ...) -> Tuple[str, ...]: ...
    def longitude(self) -> Decimal: ...
    def ascii_company_email(self) -> str: ...
    def ascii_email(self) -> str: ...
    def ascii_free_email(self) -> str: ...
    def ascii_safe_email(self) -> str: ...
    def company_email(self) -> str: ...
    def dga(
        self,
        year: Optional[int] = ...,
        month: Optional[int] = ...,
        day: Optional[int] = ...,
        tld: Optional[str] = ...,
        length: Optional[int] = ...,
    ) -> str: ...
    def domain_name(self, levels: int = ...) -> str: ...
    def domain_word(self) -> str: ...
    def email(self, safe: bool = ..., domain: Optional[str] = ...) -> str: ...
    def free_email(self) -> str: ...
    def free_email_domain(self) -> str: ...
    def hostname(self, levels: int = ...) -> str: ...
    def http_method(self) -> str: ...
    def iana_id(self) -> str: ...
    def image_url(
        self, width: Optional[int] = ..., height: Optional[int] = ..., placeholder_url: Optional[str] = ...
    ) -> str: ...
    def ipv4(self, network: bool = ..., address_class: Optional[str] = ..., private: Optional[str] = ...) -> str: ...
    def ipv4_network_class(self) -> str: ...
    def ipv4_private(self, network: bool = ..., address_class: Optional[str] = ...) -> str: ...
    def ipv4_public(self, network: bool = ..., address_class: Optional[str] = ...) -> str: ...
    def ipv6(self, network: bool = ...) -> str: ...
    def mac_address(self, multicast: bool = ...) -> str: ...
    def nic_handle(self, suffix: str = ...) -> str: ...
    def nic_handles(self, count: int = ..., suffix: str = ...) -> List[str]: ...
    def port_number(self, is_system: bool = ..., is_user: bool = ..., is_dynamic: bool = ...) -> int: ...
    def ripe_id(self) -> str: ...
    def safe_domain_name(self) -> str: ...
    def safe_email(self) -> str: ...
    def slug(self, value: Optional[str] = ...) -> str: ...
    def tld(self) -> str: ...
    def uri(self, schemes: Optional[List[str]] = ..., deep: Optional[int] = ...) -> str: ...
    def uri_extension(self) -> str: ...
    def uri_page(self) -> str: ...
    def uri_path(self, deep: Optional[int] = ...) -> str: ...
    def url(self, schemes: Optional[List[str]] = ...) -> str: ...
    def user_name(self) -> str: ...
    def isbn10(self, separator: str = ...) -> str: ...
    def isbn13(self, separator: str = ...) -> str: ...
    def job(self) -> str: ...
    def paragraph(
        self, nb_sentences: int = ..., variable_nb_sentences: bool = ..., ext_word_list: Optional[Sequence[str]] = ...
    ) -> str: ...
    def paragraphs(self, nb: int = ..., ext_word_list: Optional[Sequence[str]] = ...) -> List[str]: ...
    def sentence(
        self, nb_words: int = ..., variable_nb_words: bool = ..., ext_word_list: Optional[Sequence[str]] = ...
    ) -> str: ...
    def sentences(self, nb: int = ..., ext_word_list: Optional[Sequence[str]] = ...) -> List[str]: ...
    def text(self, max_nb_chars: int = ..., ext_word_list: Optional[Sequence[str]] = ...) -> str: ...
    def texts(
        self, nb_texts: int = ..., max_nb_chars: int = ..., ext_word_list: Optional[Sequence[str]] = ...
    ) -> List[str]: ...
    def word(self, part_of_speech: Optional[str] = ..., ext_word_list: Optional[Sequence[str]] = ...) -> str: ...
    def words(
        self,
        nb: int = ...,
        part_of_speech: Optional[str] = ...,
        ext_word_list: Optional[Sequence[str]] = ...,
        unique: bool = ...,
    ) -> List[str]: ...
    def binary(self, length: int = ...) -> bytes: ...
    def boolean(self, chance_of_getting_true: int = ...) -> bool: ...
    def csv(
        self,
        header: Optional[Sequence[str]] = ...,
        data_columns: Tuple[str, str] = ...,
        num_rows: int = ...,
        include_row_ids: bool = ...,
    ) -> str: ...
    def dsv(
        self,
        dialect: str = ...,
        header: Optional[Sequence[str]] = ...,
        data_columns: Tuple[str, str] = ...,
        num_rows: int = ...,
        include_row_ids: bool = ...,
        **fmtparams: Any
    ) -> str: ...
    def fixed_width(self, data_columns: Optional[list] = ..., num_rows: int = ..., align: str = ...) -> str: ...
    def image(
        self,
        size: Tuple[int, int] = ...,
        image_format: str = ...,
        hue: Union[int, Sequence[int], str, None] = ...,
        luminosity: Optional[str] = ...,
    ) -> bytes: ...
    def json(
        self,
        data_columns: Optional[List] = ...,
        num_rows: int = ...,
        indent: Optional[int] = ...,
        cls: Optional[Type[JSONEncoder]] = ...,
    ) -> str: ...
    def json_bytes(
        self,
        data_columns: Optional[List] = ...,
        num_rows: int = ...,
        indent: Optional[int] = ...,
        cls: Optional[Type[JSONEncoder]] = ...,
    ) -> bytes: ...
    def md5(self, raw_output: bool = ...) -> Union[bytes, str]: ...
    def null_boolean(self) -> Optional[bool]: ...
    def password(
        self,
        length: int = ...,
        special_chars: bool = ...,
        digits: bool = ...,
        upper_case: bool = ...,
        lower_case: bool = ...,
    ) -> str: ...
    def psv(
        self,
        header: Optional[Sequence[str]] = ...,
        data_columns: Tuple[str, str] = ...,
        num_rows: int = ...,
        include_row_ids: bool = ...,
    ) -> str: ...
    def sha1(self, raw_output: bool = ...) -> Union[bytes, str]: ...
    def sha256(self, raw_output: bool = ...) -> Union[bytes, str]: ...
    def tar(
        self,
        uncompressed_size: int = ...,
        num_files: int = ...,
        min_file_size: int = ...,
        compression: Optional[str] = ...,
    ) -> bytes: ...
    def tsv(
        self,
        header: Optional[Sequence[str]] = ...,
        data_columns: Tuple[str, str] = ...,
        num_rows: int = ...,
        include_row_ids: bool = ...,
    ) -> str: ...
    def uuid4(
        self, cast_to: Union[Callable[[UUID], str], Callable[[UUID], bytes], None] = ...
    ) -> Union[bytes, str, UUID]: ...
    def xml(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> str: ...
    def zip(
        self,
        uncompressed_size: int = ...,
        num_files: int = ...,
        min_file_size: int = ...,
        compression: Optional[str] = ...,
    ) -> bytes: ...
    def passport_dates(self, birthday: datetime.date = ...) -> Tuple[str, str, str]: ...
    def passport_dob(self) -> datetime.date: ...
    def passport_full(self) -> str: ...
    def passport_gender(self, seed: int = ...) -> str: ...
    def passport_number(self) -> str: ...
    def passport_owner(self, gender: str = ...) -> Tuple[str, str]: ...
    def first_name(self) -> str: ...
    def first_name_female(self) -> str: ...
    def first_name_male(self) -> str: ...
    def first_name_nonbinary(self) -> str: ...
    def language_name(self) -> str: ...
    def last_name(self) -> str: ...
    def last_name_female(self) -> str: ...
    def last_name_male(self) -> str: ...
    def last_name_nonbinary(self) -> str: ...
    def name(self) -> str: ...
    def name_female(self) -> str: ...
    def name_male(self) -> str: ...
    def name_nonbinary(self) -> str: ...
    def prefix(self) -> str: ...
    def prefix_female(self) -> str: ...
    def prefix_male(self) -> str: ...
    def prefix_nonbinary(self) -> str: ...
    def suffix(self) -> str: ...
    def suffix_female(self) -> str: ...
    def suffix_male(self) -> str: ...
    def suffix_nonbinary(self) -> str: ...
    def basic_phone_number(self) -> str: ...
    def country_calling_code(self) -> str: ...
    def msisdn(self) -> str: ...
    def phone_number(self) -> str: ...
    def profile(
        self, fields: Optional[List[str]] = ..., sex: Optional[Literal["M", "F"]] = ...
    ) -> Dict[str, Union[str, Tuple[Decimal, Decimal], List[str], datetime.date]]: ...
    def simple_profile(
        self, sex: Optional[Literal["M", "F"]] = ...
    ) -> Dict[str, Union[str, datetime.date, Literal["M", "F"]]]: ...
    def enum(self, enum_cls: Type[TEnum]) -> TEnum: ...
    def pybool(self, truth_probability: int = ...) -> bool: ...
    def pydecimal(
        self,
        left_digits: Optional[int] = ...,
        right_digits: Optional[int] = ...,
        positive: bool = ...,
        min_value: Optional[float] = ...,
        max_value: Optional[float] = ...,
    ) -> Decimal: ...
    def pydict(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> Dict[Any, Any]: ...
    def pyfloat(self, left_digits=..., right_digits=..., positive=..., min_value=..., max_value=...): ...
    def pyint(self, min_value: int = ..., max_value: int = ..., step: int = ...) -> int: ...
    def pyiterable(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> Iterable[Any]: ...
    def pylist(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> List[Any]: ...
    def pyobject(
        self, object_type: Optional[Type[Union[bool, str, float, int, tuple, set, list, Iterable, dict]]] = ...
    ) -> Union[bool, str, float, int, tuple, set, list, Iterable, dict, None]: ...
    def pyset(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> Set[Any]: ...
    def pystr(
        self, min_chars: Optional[int] = ..., max_chars: int = ..., prefix: str = ..., suffix: str = ...
    ) -> str: ...
    def pystr_format(self, string_format: str = ..., letters: str = ...) -> str: ...
    def pystruct(
        self,
        count: int = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> Tuple[List, Dict, Dict]: ...
    def pytuple(
        self,
        nb_elements: int = ...,
        variable_nb_elements: bool = ...,
        value_types: Union[List[Type], Tuple[Type, ...], None] = ...,
        allowed_types: Union[List[Type], Tuple[Type, ...], None] = ...,
    ) -> Tuple[Any, ...]: ...
    def sbn9(self, separator: str = ...) -> str: ...
    def ein(self) -> str: ...
    def invalid_ssn(self) -> str: ...
    def itin(self) -> str: ...
    def ssn(self, taxpayer_identification_number_type: str = ...) -> str: ...
    def android_platform_token(self) -> str: ...
    def chrome(
        self, version_from: int = ..., version_to: int = ..., build_from: int = ..., build_to: int = ...
    ) -> str: ...
    def firefox(self) -> str: ...
    def internet_explorer(self) -> str: ...
    def ios_platform_token(self) -> str: ...
    def linux_platform_token(self) -> str: ...
    def linux_processor(self) -> str: ...
    def mac_platform_token(self) -> str: ...
    def mac_processor(self) -> str: ...
    def opera(self) -> str: ...
    def safari(self) -> str: ...
    def user_agent(self) -> str: ...
    def windows_platform_token(self) -> str: ...
    def area_code(self) -> str: ...
    def cellphone_number(self) -> str: ...
    def cellphone_provider_code(self) -> str: ...
    def service_phone_number(self) -> str: ...
    def telephone_number(self) -> str: ...
    def telephone_provider_code(self) -> str: ...
    def toll_number(self) -> str: ...
    def initials(self) -> str: ...
    def operator_id(self) -> str: ...
    def district(self) -> str: ...
    def provider_code(self) -> str: ...
    def license_plate_ar(self) -> str: ...
    def license_plate_en(self) -> str: ...
    def district_suffix(self): ...
    def house_number(self): ...
    def settlement(self): ...
    def settlement_suffix(self): ...
    def street(self): ...
    def village(self): ...
    def village_suffix(self): ...
    def bank(self): ...
    def large_company(self): ...
    def last_name_unique_to_female(self): ...
    def last_name_unique_to_male(self): ...
    def last_name_unisex(self): ...
    def landline_number(self) -> str: ...
    def start_digit(self) -> str: ...
    def vat_id(self) -> str: ...
    def area_name(self) -> str: ...
    def building_name(self) -> str: ...
    def town(self) -> str: ...
    def city_name(self) -> str: ...
    def vehicle_category_letter(self) -> str: ...
    def vehicle_category_number(self) -> str: ...
    def vehicle_serial_number(self) -> str: ...
    def first_name_female_common(self) -> str: ...
    def first_name_female_hinduism(self) -> str: ...
    def first_name_female_islamic(self) -> str: ...
    def first_name_male_common(self) -> str: ...
    def first_name_male_hinduism(self) -> str: ...
    def first_name_male_islamic(self) -> str: ...
    def last_name_common(self) -> str: ...
    def last_name_female_islamic(self) -> str: ...
    def last_name_hinduism(self) -> str: ...
    def last_name_islamic(self) -> str: ...
    def city_with_postcode(self) -> str: ...
    def street_suffix_long(self) -> str: ...
    def street_suffix_short(self) -> str: ...
    def birth_number(self) -> str: ...
    def dk_street_name(self) -> str: ...
    def local_latitude(self) -> Decimal: ...
    def local_longitude(self) -> Decimal: ...
    def canton(self) -> Tuple[str, str]: ...
    def canton_code(self) -> str: ...
    def canton_name(self) -> str: ...
    def line_address(self) -> str: ...
    def region(self) -> str: ...
    def street_prefix(self) -> str: ...
    def street_prefix_long(self) -> str: ...
    def street_prefix_short(self) -> str: ...
    def police_id(self) -> str: ...
    def tin(self) -> str: ...
    def postal_code_letter(self) -> str: ...
    def postalcode_in_province(self, province_abbr: Optional[str] = ...) -> str: ...
    def postcode_in_province(self, province_abbr: Optional[str] = ...) -> str: ...
    def province(self) -> str: ...
    def province_abbr(self) -> str: ...
    def county(self) -> str: ...
    def aadhaar_id(self) -> str: ...
    def rd_number(self) -> str: ...
    def te_reo_ending(self) -> str: ...
    def te_reo_first(self) -> str: ...
    def te_reo_part(self) -> str: ...
    def building_name_suffix(self) -> str: ...
    def building_unit_number(self) -> str: ...
    def floor_number(self) -> str: ...
    def floor_unit_number(self) -> str: ...
    def luzon_province(self) -> str: ...
    def luzon_province_address(self) -> str: ...
    def luzon_province_postcode(self) -> str: ...
    def metro_manila_address(self) -> str: ...
    def metro_manila_lgu(self) -> str: ...
    def metro_manila_postcode(self) -> str: ...
    def mindanao_province(self) -> str: ...
    def mindanao_province_address(self) -> str: ...
    def mindanao_province_postcode(self) -> str: ...
    def ordinal_floor_number(self) -> str: ...
    def ordinal_street_number(self) -> str: ...
    def partitioned_building_number(self) -> str: ...
    def province_lgu(self) -> str: ...
    def standalone_building_number(self) -> str: ...
    def subdivision_block_number(self) -> str: ...
    def subdivision_lot_number(self) -> str: ...
    def subdivision_name(self) -> str: ...
    def subdivision_name_suffix(self) -> str: ...
    def subdivision_unit_number(self) -> str: ...
    def visayas_province(self) -> str: ...
    def visayas_province_address(self) -> str: ...
    def visayas_province_postcode(self) -> str: ...
    def automobile_license_plate(self) -> str: ...
    def motorcycle_license_plate(self) -> str: ...
    def protocol_license_plate(self) -> str: ...
    def company_type(self) -> str: ...
    def random_company_acronym(self) -> str: ...
    def random_company_adjective(self) -> str: ...
    def random_company_noun_chain(self) -> str: ...
    def random_company_product(self) -> str: ...
    def english_paragraph(self, nb_sentences: int = ..., variable_nb_sentences: bool = ...) -> str: ...
    def english_paragraphs(self, nb: int = ...) -> List[str]: ...
    def english_sentence(self, nb_words: int = ..., variable_nb_words: bool = ...) -> str: ...
    def english_sentences(self, nb: int = ...) -> List[str]: ...
    def english_text(self, max_nb_chars: int = ...) -> str: ...
    def english_texts(self, nb_texts: int = ..., max_nb_chars: int = ...) -> List[str]: ...
    def english_word(self) -> str: ...
    def english_words(self, nb: int = ..., unique: bool = ...) -> List[str]: ...
    def gemstone_name(self) -> str: ...
    def mountain_name(self) -> str: ...
    def plant_name(self) -> str: ...
    def random_object_name(self) -> str: ...
    def space_object_name(self) -> str: ...
    def area2_landline_number(self) -> str: ...
    def bayantel_area2_landline_number(self) -> str: ...
    def bayantel_landline_identifier(self) -> str: ...
    def globe_area2_landline_number(self) -> str: ...
    def globe_mobile_number(self) -> str: ...
    def globe_mobile_number_prefix(self) -> str: ...
    def misc_area2_landline_number(self) -> str: ...
    def misc_landline_identifier(self) -> str: ...
    def mobile_number(self) -> str: ...
    def non_area2_landline_area_code(self) -> str: ...
    def non_area2_landline_number(self) -> str: ...
    def pldt_area2_landline_number(self) -> str: ...
    def smart_mobile_number(self) -> str: ...
    def smart_mobile_number_prefix(self) -> str: ...
    def sun_mobile_number(self) -> str: ...
    def sun_mobile_number_prefix(self) -> str: ...
    def gsis(self) -> str: ...
    def pagibig(self) -> str: ...
    def philhealth(self) -> str: ...
    def sss(self) -> str: ...
    def umid(self) -> str: ...
    def municipality(self) -> str: ...
    def municipality_code(self) -> str: ...
    def provinces_code(self) -> str: ...
    def street_municipality(self) -> str: ...
    def street_procer(self) -> str: ...
    def street_province(self) -> str: ...
    def license_plate_mercosur(self) -> str: ...
    def license_plate_old(self) -> str: ...
    def cif(self) -> str: ...
    def doi(self) -> str: ...
    def nie(self) -> str: ...
    def nif(self) -> str: ...
    def nuss(self, company: bool = ...) -> str: ...
    def common_street_name(self) -> str: ...
    def commune(self) -> str: ...
    def commune_and_region(self) -> str: ...
    def commune_code(self) -> str: ...
    def highway_name(self) -> str: ...
    def historic_people_street_name(self) -> str: ...
    def plant_street_name(self) -> str: ...
    def province_code(self) -> str: ...
    def region_code(self) -> str: ...
    def road_name(self) -> str: ...
    def license_plate_diplomatic(self) -> str: ...
    def license_plate_new(self) -> str: ...
    def license_plate_police(self) -> str: ...
    def license_plate_temporary(self) -> str: ...
    def company_prefix(self) -> str: ...
    def given_name(self) -> str: ...
    def given_name_female(self) -> str: ...
    def given_name_male(self) -> str: ...
    def cellphone_block(self) -> str: ...
    def landline_code(self) -> str: ...
    def special_code(self) -> str: ...
    def company_rut(self) -> str: ...
    def person_rut(self) -> str: ...
    def rut(self, min: int = ..., max: int = ...) -> str: ...
    def department(self) -> str: ...
    def department_code(self) -> str: ...
    def legal_person_nit(self) -> str: ...
    def legal_person_nit_with_check_digit(self) -> str: ...
    def natural_person_nit(self) -> str: ...
    def natural_person_nit_with_check_digit(self) -> str: ...
    def nuip(self) -> str: ...
    def autonomous_community(self) -> str: ...
    def state_name(self) -> str: ...
    def license_plate_by_province(self, province_prefix: Optional[str] = ...) -> str: ...
    def license_plate_unified(self) -> str: ...
    def random_name_complements(self) -> str: ...
    def city_adjective(self) -> str: ...
    def clabe(self, bank_code: Optional[int] = ...) -> str: ...
    def curp(self) -> str: ...
    def elector_code(self, gender: Optional[Literal["H", "M"]] = ...) -> str: ...
    def rfc(self, natural: bool = ...) -> str: ...
    def first_name_est(self) -> str: ...
    def first_name_female_est(self) -> str: ...
    def first_name_female_rus(self) -> str: ...
    def first_name_male_est(self) -> str: ...
    def first_name_male_rus(self) -> str: ...
    def first_name_rus(self) -> str: ...
    def last_name_est(self) -> str: ...
    def last_name_rus(self) -> str: ...
    def company_business_id(self) -> str: ...
    def company_vat(self) -> str: ...
    def english_catch_phrase(self) -> str: ...
    def random_good_service_adjective(self) -> str: ...
    def random_good_service_adjective_chain(self) -> str: ...
    def random_noun_ish_good_trait(self) -> str: ...
    def random_object_of_concern(self) -> str: ...
    def catch_phrase_attribute(self) -> str: ...
    def catch_phrase_noun(self) -> str: ...
    def catch_phrase_verb(self) -> str: ...
    def ide(self) -> str: ...
    def idi(self) -> str: ...
    def siren(self) -> str: ...
    def siret(self, max_sequential_digits: int = ...) -> str: ...
    def uid(self) -> str: ...
    def department_name(self) -> str: ...
    def department_number(self) -> str: ...
    def area_code_with_separator(self) -> str: ...
    def area_code_without_separator(self) -> str: ...
    def street_title(self) -> str: ...
    def city_part(self) -> str: ...
    def frequent_street_name(self) -> str: ...
    def real_city_name(self) -> str: ...
    def street_address_with_county(self) -> str: ...
    def first_name_female_abbreviated(self) -> str: ...
    def first_name_male_abbreviated(self) -> str: ...
    def village_prefix(self) -> str: ...
    def postcode_city_province(self) -> str: ...
    @staticmethod
    def is_leap_year(year: int) -> bool: ...
    def ban(self) -> str: ...
    def chome(self) -> str: ...
    def gou(self) -> str: ...
    def prefecture(self) -> str: ...
    def jan(self, length: int = ...) -> str: ...
    def jan13(self) -> str: ...
    def jan8(self) -> str: ...
    def company_category(self) -> str: ...
    def traditional_month_name(self) -> str: ...
    def first_kana_name(self) -> str: ...
    def first_kana_name_female(self) -> str: ...
    def first_kana_name_male(self) -> str: ...
    def first_name_female_pair(self) -> Tuple[str, str, str]: ...
    def first_name_male_pair(self) -> Tuple[str, str, str]: ...
    def first_name_pair(self) -> Tuple[str, str, str]: ...
    def first_romanized_name(self) -> str: ...
    def first_romanized_name_female(self) -> str: ...
    def first_romanized_name_male(self) -> str: ...
    def kana_name(self) -> str: ...
    def kana_name_female(self) -> str: ...
    def kana_name_male(self) -> str: ...
    def last_kana_name(self) -> str: ...
    def last_name_pair(self) -> Tuple[str, str, str]: ...
    def last_romanized_name(self) -> str: ...
    def romanized_name(self) -> str: ...
    def romanized_name_female(self) -> str: ...
    def romanized_name_male(self) -> str: ...
    def address_detail(self) -> str: ...
    def borough(self) -> str: ...
    def building_dong(self) -> str: ...
    def building_suffix(self) -> str: ...
    def land_address(self) -> str: ...
    def land_number(self) -> str: ...
    def metropolitan_city(self) -> str: ...
    def old_postal_code(self) -> str: ...
    def postal_code(self) -> str: ...
    def road(self) -> str: ...
    def road_address(self) -> str: ...
    def road_number(self) -> str: ...
    def road_suffix(self) -> str: ...
    def town_suffix(self) -> str: ...
    def building_prefix(self) -> str: ...
    def license_plate_car(self) -> str: ...
    def license_plate_motorbike(self) -> str: ...
    def first_name_unisex(self) -> str: ...
    def middle_name(self) -> str: ...
    def license_plate_regex_formats(self) -> List[str]: ...
    def local_regon(self) -> str: ...
    def regon(self) -> str: ...
    def identity_card_number(self) -> str: ...
    def nip(self) -> str: ...
    def pesel(self, date_of_birth: Optional[datetime.datetime] = ..., sex: Optional[str] = ...) -> str: ...
    @staticmethod
    def pesel_compute_check_digit(pesel: str) -> int: ...
    def pwz_doctor(self) -> str: ...
    @staticmethod
    def pwz_doctor_compute_check_digit(x: Sequence[int]) -> int: ...
    def pwz_nurse(self, kind: str = ...) -> str: ...
    def bairro(self) -> str: ...
    def estado(self) -> Tuple[str, str]: ...
    def estado_nome(self) -> str: ...
    def estado_sigla(self) -> str: ...
    def neighborhood(self) -> str: ...
    def cnpj(self) -> str: ...
    def company_id(self) -> str: ...
    def cpf(self) -> str: ...
    def rg(self) -> str: ...
    def concelho(self) -> str: ...
    def distrito(self) -> str: ...
    def freguesia(self) -> str: ...
    def place_name(self) -> str: ...
    def nationality(self) -> str: ...
    def plate_letter(self) -> str: ...
    def plate_number(self) -> str: ...
    def plate_number_extra(self) -> str: ...
    def plate_number_special(self) -> str: ...
    def plate_suffix(self) -> str: ...
    def vehicle_category(self) -> str: ...
    def bic(self) -> str: ...
    def checking_account(self) -> str: ...
    def correspondent_account(self) -> str: ...
    def businesses_inn(self) -> str: ...
    def businesses_ogrn(self) -> str: ...
    def individuals_inn(self) -> str: ...
    def individuals_ogrn(self) -> str: ...
    def kpp(self) -> str: ...
    def middle_name_female(self) -> str: ...
    def middle_name_male(self) -> str: ...
    def org_and_vat_id(self, long: bool = ..., dash: bool = ...) -> Tuple[str, str]: ...
    def org_id(self, long: bool = ..., dash: bool = ...) -> str: ...
    def amphoe(self) -> str: ...
    def tambon(self) -> str: ...
    def company_limited_prefix(self) -> str: ...
    def company_limited_suffix(self) -> str: ...
    def nonprofit_prefix(self) -> str: ...
    def phonenumber_prefix(self) -> int: ...
    def city_name_suffix(self) -> str: ...
    def section_number(self) -> str: ...
    def street_name_suffix(self) -> str: ...
    def minguo_year(self) -> str: ...
    def __deepcopy__(self, memodict: Dict = ...) -> "Faker": ...
    def __dir__(self): ...
    def __getattr__(self, attr: str) -> Any: ...
    def __getattribute__(self, attr: str) -> Any: ...
    def __getitem__(self, locale: str) -> Generator: ...
    def __init__(
        self,
        locale: Union[str, Sequence[str], Dict[str, Union[int, float]], None] = ...,
        providers: Optional[List[str]] = ...,
        generator: Optional[Generator] = ...,
        includes: Optional[List[str]] = ...,
        use_weighting: bool = ...,
        **config: Any
    ) -> None: ...
    def __setstate__(self, state: Any) -> None: ...
    def items(self) -> List[Tuple[str, Generator]]: ...
    @classmethod
    def seed(cls, seed: Union[int, float, str, bytes, bytearray, None] = ...) -> None: ...
    def seed_instance(self, seed: Union[int, float, str, bytes, bytearray, None] = ...) -> None: ...
    def seed_locale(self, locale: str, seed: Union[int, float, str, bytes, bytearray, None] = ...) -> None: ...
